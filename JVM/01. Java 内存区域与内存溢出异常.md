> 文章可以白嫖，老铁们顺便关注一下我的公众号，手动滑稽🤣🤣 &nbsp;
>
> 欢迎大家关注：**武哥聊编程**、**Java开发宝典**、**Java秃头哥**，您的支持，是我创作的持续动力！&nbsp;&nbsp;

![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)![Java开发宝典](https://img-blog.csdnimg.cn/20200608005630228.png)![Java秃头哥](https://img-blog.csdnimg.cn/20201025170941235.png)

----

本文参考自《深入理解Java虚拟机》一书。主要总结一下java虚拟机内存的各个区域，以及这些区域的作用、服务对象以及其中可能产生的问题。

## 1. 运行时数据区域
Java虚拟机在执行 Java 程序的过程中会把它说管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。具体如下图所示：

![运行时数据区域](https://img-blog.csdnimg.cn/img_convert/aeed80ab3ccd1db2aace8f24fd9ca8aa.png)

结合这张图，下面逐个来分析一下每个数据区域的特点。

### 1.1 程序计数器（Program Counter Register）

**程序计数器**是一块较小的内存空间，<font color=red>可以看作是当前线程所执行的字节码的行号指示器</font>。啥意思呢？我们知道，CPU的计算时间是以分片的方式给到每个线程的（换句话说，所谓的并行其实本质上还是串行），比如线程A执行到了一个地方，CPU将控制权给了线程B，那么线程A重新获得CPU的资源时，如何恢复到刚才执行的地方呢？这就是程序计数器要干的事了！它能帮助线程A找到刚刚执行的地方，从而继续刚刚的执行。

为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。所以程序计数器是<font color=red>**线程私有**</font>的。

另外，程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 1.2 Java虚拟机栈

Java虚拟机栈所占有的内存空间也就是我们平时所说的“栈内存”，并且也是<font color=red>**线程私有**</font>的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时，都会创建一个栈帧，<font color=red>用于存储局部变量表（基本数据类型，**对象的引用**和returnAddress类型）、操作数栈、动态链接、方法出口等信息</font>。

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

<font color=red>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</font>。对于Java虚拟机栈，有两种异常情况：

>1）如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
>2）如果虚拟机栈在动态扩展时，无法申请到足够的内存，就会抛出OutOfMemoryError； 

### 1.3 本地方法栈

本地方法栈和虚拟机栈所发挥的作用非常相似，它们之间的区别主要是，<font color=red>虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务的，而本地方法栈则为虚拟机使用到的Native方法服务</font>。

与虚拟机栈类似，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

### 1.4 Java堆

Java堆是Java虚拟机所管理的内存中最大的一块。Java堆在主内存中，是**被所有线程共享**的一块内存区域，其随着JVM的创建而创建，<font color=red>**堆内存的唯一目的是存放对象实例和数组**。同时Java堆也是GC管理的主要区域</font>。

Java堆物理上不需要连续的内存，只要逻辑上连续即可。如果堆中没有内存完成实例分配，并且也无法再扩展时，将会抛出OutOfMemoryError异常。

### 1.5 方法区

方法去是<font color=red>**所有线程共享**</font>的一个内存区域。<font color=red>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</font>。方法区也有一个别名叫做Non-Heap（非堆），用于与Java堆区分。对于HotSpot虚拟机来说，方法区又习惯称为“永久代”（Permancent Generation），但这只是对于HotSpot虚拟机来说的，其他虚拟机的实现上并没有这个概念。相对而言，垃圾收集行为在这个区域比较少出现，但也并非不会来收集，**这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载上**。

根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。

### 1.6 运行时常量池

运行时常量池属于方法区。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量表，用于存放编译期生成的各种字面常量和符号引用，这部分内容将在**类加载后进入方法区**的运行时常量池中存放（JDK1.7开始，常量池已经被移到了堆内存中了）。也就是说，这部分内容，在编译时只是放入到了常量池信息中，到了加载时，才会放到运行时常量池中去。运行时常量池县归于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的是String类的intern()方法。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常，常量池属于方法区，同样可能抛出OutOfMemoryError异常。

下面针对内存区域模型做一个小结。

## 2. java内存区域模型总结
|内存区域|线程私有|主要作用|溢出异常|
|:--:|:--:|:--|:--:|
|程序计数器|是|记录当前线程执行的位置|无异常|
|虚拟机栈|是|存储局部变量表（基本数据类型，**对象的引用**和returnAddress类型）、操作数栈、动态链接、方法出口等信息（java方法）|StackOverflowError和OutOfMemoryError|
|本地方法栈|是|和虚拟机栈相似，区别本地方法栈为虚拟机使用到的Native方法服务|StackOverflowError和OutOfMemoryError|
|堆|否|存放对象实例和数组|OutOfMemoryError|
|方法区|否|用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据|OutOfMemoryError |

----

> 文章可以白嫖，老铁们顺便关注一下我的公众号，手动滑稽🤣🤣 &nbsp;
>
> 欢迎大家关注：**武哥聊编程**、**Java开发宝典**、**Java秃头哥**，您的支持，是我创作的持续动力！&nbsp;&nbsp;

![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)![Java开发宝典](https://img-blog.csdnimg.cn/20200608005630228.png)![Java秃头哥](https://img-blog.csdnimg.cn/20201025170941235.png)

----
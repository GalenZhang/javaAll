> 文章可以白嫖，老铁们顺便关注一下我的公众号，手动滑稽🤣🤣 &nbsp;
>
> 欢迎大家关注：**武哥聊编程**、**Java开发宝典**、**Java秃头哥**，您的支持，是我创作的持续动力！&nbsp;&nbsp;

![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)![Java开发宝典](https://img-blog.csdnimg.cn/20200608005630228.png)![Java秃头哥](https://img-blog.csdnimg.cn/20201025170941235.png)

----

这篇博文主要来总结一下java虚拟机加载一个类的过程，部分参考自《深入理解Java虚拟机》。

## 1. 一个经典的面试题
为了避免枯燥的解说，为了让读者在读完本文后能彻底理解类加载的过程，首先来看一段 Java 代码，我们从一个例子入手：

```java
//ClassLoaderProcess.java文件
class Singleton {
	private static Singleton singleton = new Singleton();
	public static int count_1;
	public static int count_2 = 0;

	static {
		count_1++;
		count_2++;
	}

	private Singleton() {
		count_1++;
		count_2++;
	}
	
	public static Singleton getInstance() {
		return singleton;
	}
}

public class ClassLoaderProcess {	
	
	public static void main(String[] args) {
		System.out.println(Singleton.count_1);
		System.out.println(Singleton.count_2);
	}
}
```
Singleton是个单例模式的类，里面有两个静态变量，在静态代码块中对两个静态变量做自增运算，在私有构造方法中，再对这两个静态变量做自增运算，最后打印出来的结果是多少呢？先说一下正确答案不是2和2，而是2和1。我们带着这个问题去分析虚拟机是如何加载一个类的（如果对虚拟机加载类的过程已经很清楚了，就可以不用往下看了）。看完本文，相信你也会从虚拟机加载类的过程中来分析这段java代码了。

## 2. 虚拟机加载类的过程
### 2.1 类的生命周期
![类的加载过程](https://img-blog.csdnimg.cn/img_convert/ae91b8a134a525ec1283309ec5f7c34f.png)

上图表示一个类的生命周期图。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、连接（验证、准备、解析）、初始化、使用和卸载7个阶段。其中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它再某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定。下面来逐个分析一下类加载的各个过程。

### 2.2 加载

我们知道，程序要加载到内存中才可以执行，什么情况下需要开始类加载过程的第一阶段：加载呢？java虚拟机规范中并没有进行强制约定，这点可以交给虚拟机的具体实现来自由把握。

在加载阶段，java虚拟机需要完成以下3件事情:
>1. 通过一个类的全限定名来获取定义此类的二进制字节流<br>
>2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>
>3. 在内存中（堆中）生成一个代表这个类的java.lang.Class对象，用来封装类在方法区里的数据结构，作为方法区中这个类的各种数据的访问入口

从这三个步骤中可以很明显的看出，我们可以通过这个Class来获取类的各种数据，它就像是一面镜子，可以反射出类的信息来，所以也就明白了在用反射的时候为什么要使用Class了。

### 2.3 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

一般我们都是通过java文件编译生成的class文件，这是没有什么问题的，但是class文件并不一定要求用java源码编译而来，可以使用很多其它的途径，比如用十六进制编辑器直接编写来产生class文件。虚拟机如果不检查输入的字节流，对其完全信任的话，可能就会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机的一项重要的工作。

### 2.4 准备

接下来就是连接的第二步：准备了。**准备阶段是正式为类变量分配内存并设置类变量的初始值的阶段**。这里有两个概念要搞清楚：
>1. 类变量：即被static修饰的静态变量。<br>
>2. 初始值：指的是该数据类型所对应的“零值”<br>

所以也就是说，**<font color=red>准备阶段是为静态变量分配内存，并且对其初始化为零值</font>**。不包括静态代码块和实例变量，静态代码块在下面的初始化阶段执行，实例变量将会在对象实例化的时候随着对象一起分到到java堆中的。例如：

```java
public static int value = 123;
```
在准备阶段，value的值为0，并非123！当然咯，如果是boolean型数据，则为false。零值是针对具体类型来说的。

### 2.5 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**，这个符号引用和直接引用有什么关联呢？
>1. 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。<br>
>2. 直接引用：指的是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，引用的目标必定已经在内存中存在。

### 2.6 初始化

初始化是类加载过程的最后一步，在前面的过程中，除了第一步加载阶段用户可以通过指定自定义类加载器参与外，其余过程完全是由虚拟机自己主导控制的。到了初始化阶段，才真正开始执行类中定义的java程序代码了（或者说是字节码）。

由上面分析可知，在准备阶段，静态变量已经赋过一次值了，只不过是系统要求的初始值而已，而<font color=red>**在初始化阶段，为类的静态变量赋予程序中指定的初始值，还有执行静态代码块中的程序**</font>。

关于类的初始化这个阶段，可以再分析的深入一点，刚刚说初始化的阶段是为类的静态变量赋实际值的阶段，我们也可以从另外的一个角度去表达：**初始化阶段是执行类构造器方法（注意：不是我们平时说的类的构造方法）的过程**，构造器方法是`<cinit>()`方法，**它是由编译器自动收集类中所有的静态变量的赋值动作和静态代码块中的语句合并产生的**，所以也就清楚了，为啥初始化阶段也可以叫做类构造器方法执行的过程。

这里需要注意的是，编译器收集的顺序是由语句在程序中出现的顺序所决定的，静态代码块中只能访问到定义在静态代码块之前的变量，定义在它之后的变量，在前面的静态代码块中可以赋值，但是不能访问。可以举个例子：

```java
public class Test {
	static {
		i = 0; //给变量赋值可以正常通过编译
		System.out.print(i); //但是不能访问，这句编译会提示非法向前引用
	}
	static int i = 1;
```

`<cinit>()`方法与类的构造函数不同，它不需要显示的调用父类的构造器，虚拟机会保证在子类的`<cinit>()`方法执行前，父类的`<cinit>()`方法已经执行完毕，所以在虚拟机中第一个被执行的`<cinit>()`方法的类肯定是java.lang.Object。

由于父类的`<cinit>()`方法先执行，也就意味着父类中定义的静态代码块要优先于子类的静态变量赋值操作，看一个例子：

```java
//演示虚拟机<cinit>方法执行的过程
public class CinitMethod {

	static class Parent{
		public static int A = 1;
		static {
			A = 2;
		}		
	}
	
	static class Sub extends Parent {
		public static int B = A;
	}
	
	public static void main(String[] args) {
		System.out.println(Sub.B);
	}
}
```

这段程序中，在准备阶段，先将A赋为0，B赋为0，在初始化阶段，先执行父类的`<cinit>()`方法，所以会执行A=1；然后A=2，然后执行子类的`<cinit>()`方法，执行B=A，所以打印出来是2。

虚拟机会保证一个类的`<cinit>()`方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<cinit>()`方法，其它线程都需要阻塞等待，直到活动线程执行完该方法。

到这里，一个类的加载过程就算完毕了，**<font color=red>类加载的最终产品是位于堆中的Class对象，封装了类在方法区内的数据结构，并向java程序员提供了访问方法区内数据结构的接口</font>**。所以程序员就可以使用可以使用这个类去获取与该类相关的信息了。

要注意的是，这是类加载完毕了，跟类的对象是没有关系的，到目前只能使用类的静态变量和静态方法，类的对象需要我们去产生的，有了对象才能操作其中的普通成员变量和方法。 

现在再去看文章开头的那段java代码应该很简单了

>1. 在准备阶段，java虚拟机将Singleton赋为空，count_1和count_2赋为0（count_2赋为0不是程序中赋的0，是int的默认值）。<br>
>2. 在初始化阶段，java虚拟机按照顺序执行static代码，<br>
>首先实例化Singleton，执行构造方法中的代码，count_1和cout_2变成1；<br>
>然后按顺序执行static代码，count_1没有赋值，还是1，count_2被赋值为0；<br>
>最后执行静态代码块中的代码，count_1和count_2各自增1，所以count_1=2，count_2=1。

分析完毕。

----

> 文章可以白嫖，老铁们顺便关注一下我的公众号，手动滑稽🤣🤣 &nbsp;
>
> 欢迎大家关注：**武哥聊编程**、**Java开发宝典**、**Java秃头哥**，您的支持，是我创作的持续动力！&nbsp;&nbsp;

![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)![Java开发宝典](https://img-blog.csdnimg.cn/20200608005630228.png)![Java秃头哥](https://img-blog.csdnimg.cn/20201025170941235.png)

----